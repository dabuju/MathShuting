<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Algebra Survival Shooting</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050a14; touch-action: none; font-family: 'Courier New', sans-serif; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- 音声エンジン ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function playSfx(f, t, d, v=0.05) {
    if(!audioCtx) audioCtx = new AudioContext();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = t; o.frequency.value = f;
    g.gain.setValueAtTime(v, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + d);
}

// --- ゲーム変数 ---
let score = 0;
let lives = 3;
let isGameOver = false;
let coeff = 1, leftConst = 0, rightSide = 0;
const player = { x: 0, y: 0, size: 20, speed: 7, invul: 0 }; // invulは無敵時間
const bullets = [];
const enemies = [];
const joystick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    player.x = canvas.width / 2;
    player.y = canvas.height * 0.8;
}
window.addEventListener('resize', resize);
resize();

function generateEquation() {
    const ans = Math.floor(Math.random() * 9) + 1;
    coeff = Math.floor(Math.random() * 3) + 2;
    leftConst = Math.floor(Math.random() * 10) + 1;
    rightSide = coeff * ans + leftConst;
}

function spawnEnemy() {
    if (isGameOver) return;
    const r = Math.random();
    let type, val, label, color;
    if (r < 0.4) {
        type = Math.random() > 0.5 ? '-' : '+';
        val = (leftConst !== 0 && Math.random() > 0.7) ? Math.abs(leftConst) : Math.floor(Math.random() * 5) + 1;
        label = (type === '-' ? '－' : '＋') + val;
        color = '#ff4757';
    } else {
        type = Math.random() > 0.5 ? '/' : '*';
        val = (type === '/' && coeff !== 1) ? coeff : Math.floor(Math.random() * 2) + 2;
        label = (type === '/' ? '÷' : '×') + val;
        color = '#54a0ff';
    }
    enemies.push({ x: Math.random() * (canvas.width - 60) + 30, y: -50, type, val, label, color, speed: 2 + Math.random() * 2 });
}

// --- 入力 ---
canvas.addEventListener('touchstart', (e) => {
    if (isGameOver) { // ゲームオーバー時にタップでリスタート
        score = 0; lives = 3; isGameOver = false;
        generateEquation(); enemies.length = 0; bullets.length = 0;
        return;
    }
    for (let t of e.changedTouches) {
        if (t.clientX < canvas.width / 2) {
            joystick.active = true;
            joystick.startX = joystick.currX = t.clientX;
            joystick.startY = joystick.currY = t.clientY;
        } else {
            bullets.push({ x: player.x, y: player.y - 20 });
            playSfx(800, 'triangle', 0.1);
        }
    }
}, false);

canvas.addEventListener('touchmove', (e) => {
    if (joystick.active) {
        joystick.currX = e.touches[0].clientX;
        joystick.currY = e.touches[0].clientY;
    }
}, false);

canvas.addEventListener('touchend', () => { joystick.active = false; }, false);

// --- メインループ ---
function update() {
    if (isGameOver) { draw(); requestAnimationFrame(update); return; }

    // 無敵カウントダウン
    if (player.invul > 0) player.invul--;

    // 自機移動
    if (joystick.active) {
        const dx = joystick.currX - joystick.startX;
        const dy = joystick.currY - joystick.startY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > 5) {
            player.x = Math.max(20, Math.min(canvas.width-20, player.x + (dx/dist)*player.speed));
            player.y = Math.max(20, Math.min(canvas.height-20, player.y + (dy/dist)*player.speed));
        }
    }

    // 弾移動
    bullets.forEach((b, bi) => {
        b.y -= 12;
        if (b.y < 0) bullets.splice(bi, 1);
    });

    // 敵移動と当たり判定
    if (Math.random() < 0.02) spawnEnemy();
    enemies.forEach((en, ei) => {
        en.y += en.speed;
        if (en.y > canvas.height) enemies.splice(ei, 1);

        // 自機との当たり判定
        const distToPlayer = Math.sqrt((player.x - en.x)**2 + (player.y - en.y)**2);
        if (distToPlayer < 40 && player.invul === 0) {
            lives--;
            player.invul = 60; // 1秒間無敵
            playSfx(100, 'sawtooth', 0.3, 0.2); // ダメージ音
            enemies.splice(ei, 1);
            if (lives <= 0) {
                isGameOver = true;
                playSfx(50, 'sawtooth', 1.0, 0.3); // ゲームオーバー音
            }
        }

        // 弾との当たり判定
        bullets.forEach((b, bi) => {
            const dist = Math.sqrt((b.x - en.x)**2 + (b.y - en.y)**2);
            if (dist < 30) {
                if (en.type === '+') { leftConst += en.val; rightSide += en.val; }
                if (en.type === '-') { leftConst -= en.val; rightSide -= en.val; }
                if (en.type === '*') { coeff *= en.val; leftConst *= en.val; rightSide *= en.val; }
                if (en.type === '/') { coeff /= en.val; leftConst /= en.val; rightSide /= en.val; }
                
                enemies.splice(ei, 1);
                bullets.splice(bi, 1);
                
                if (Math.abs(coeff - 1) < 0.01 && Math.abs(leftConst) < 0.01) {
                    score += 150;
                    playSfx(523, 'square', 0.1); setTimeout(() => playSfx(783, 'square', 0.3), 150);
                    generateEquation();
                } else {
                    playSfx(200, 'sine', 0.1);
                }
            }
        });
    });

    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 方程式
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = 'bold 32px sans-serif';
    let lText = (coeff === 1 ? "" : (coeff === -1 ? "-" : coeff.toFixed(1))) + "x";
    if (leftConst > 0) lText += " + " + leftConst.toFixed(1);
    else if (leftConst < 0) lText += " - " + Math.abs(leftConst).toFixed(1);
    ctx.fillText(`${lText} = ${rightSide.toFixed(1)}`, canvas.width / 2, 80);

    // UI
    ctx.textAlign = 'left';
    ctx.font = '20px sans-serif';
    ctx.fillText(`SCORE: ${score}`, 20, 40);
    ctx.textAlign = 'right';
    ctx.fillText(`LIFE: ${'❤️'.repeat(lives)}`, canvas.width - 20, 40);

    // 敵
    enemies.forEach(en => {
        ctx.fillStyle = en.color;
        ctx.beginPath(); ctx.arc(en.x, en.y, 25, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = 'bold 18px sans-serif';
        ctx.fillText(en.label, en.x, en.y + 7);
    });

    // 弾
    ctx.fillStyle = '#ffff00';
    bullets.forEach(b => ctx.fillRect(b.x - 2, b.y, 4, 15));

    // 自機（無敵時は点滅）
    if (player.invul % 10 < 5) {
        ctx.fillStyle = '#00d2d3';
        ctx.beginPath();
        ctx.moveTo(player.x, player.y - 20);
        ctx.lineTo(player.x - 15, player.y + 15);
        ctx.lineTo(player.x + 15, player.y + 15);
        ctx.fill();
    }

    // ゲームオーバー画面
    if (isGameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'red';
        ctx.textAlign = 'center';
        ctx.font = 'bold 48px sans-serif';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
        ctx.fillStyle = 'white';
        ctx.font = '20px sans-serif';
        ctx.fillText('Tap to Restart', canvas.width / 2, canvas.height / 2 + 50);
    }
}

generateEquation();
update();
</script>
</body>
</html>
