<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Algebra Space Survival</title>
    <style>
        body { margin: 0; overflow: hidden; background: #02050a; touch-action: none; font-family: 'Courier New', sans-serif; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- 音声 ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function playSfx(f, t, d, v=0.05) {
    if(!audioCtx) audioCtx = new AudioContext();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = t; o.frequency.value = f;
    g.gain.setValueAtTime(v, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + d);
}

// --- ゲーム変数 ---
let score = 0;
let coeff = 1, leftConst = 0, rightSide = 0;
const player = { x: 0, y: 0, speed: 7 };
const bullets = [];
const enemies = [];
const stars = []; // 背景の星
const joystick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    player.x = canvas.width / 2;
    player.y = canvas.height * 0.8;
}
window.addEventListener('resize', resize);
resize();

// 星の初期化
for(let i=0; i<50; i++) stars.push({x: Math.random()*window.innerWidth, y: Math.random()*window.innerHeight, s: Math.random()*2});

function generateEquation() {
    const ans = Math.floor(Math.random() * 9) + 1;
    coeff = Math.floor(Math.random() * 3) + 2;
    leftConst = Math.floor(Math.random() * 10) + 1;
    rightSide = coeff * ans + leftConst;
}

function fmt(num) { return +(num.toFixed(1)); }

function applyMath(en) {
    if (en.type === '+') { leftConst += en.val; rightSide += en.val; }
    if (en.type === '-') { leftConst -= en.val; rightSide -= en.val; }
    if (en.type === '*') { coeff *= en.val; leftConst *= en.val; rightSide *= en.val; }
    if (en.type === '/') { coeff /= en.val; leftConst /= en.val; rightSide /= en.val; }
    
    // クリア判定
    if (Math.abs(coeff - 1) < 0.01 && Math.abs(leftConst) < 0.01) {
        score += 150;
        playSfx(523, 'square', 0.1); setTimeout(() => playSfx(783, 'square', 0.3), 150);
        generateEquation();
    }
}

function spawnEnemy() {
    const r = Math.random();
    let type, val, label, color;
    if (r < 0.5) {
        type = Math.random() > 0.5 ? '-' : '+';
        val = (leftConst !== 0 && Math.random() > 0.7) ? Math.abs(leftConst) : Math.floor(Math.random() * 5) + 1;
        label = (type === '-' ? '－' : '＋') + val;
        color = '#ff4757';
    } else {
        type = Math.random() > 0.5 ? '/' : '*';
        val = (type === '/' && coeff !== 1) ? coeff : Math.floor(Math.random() * 2) + 2;
        label = (type === '/' ? '÷' : '×') + val;
        color = '#54a0ff';
    }
    enemies.push({ x: Math.random() * (canvas.width - 60) + 30, y: -50, type, val, label, color, speed: 1.5 + Math.random() * 1.5 });
}

// --- 入力 ---
canvas.addEventListener('touchstart', (e) => {
    for (let t of e.changedTouches) {
        if (t.clientX < canvas.width / 2) {
            joystick.active = true;
            joystick.startX = joystick.currX = t.clientX;
            joystick.startY = joystick.currY = t.clientY;
        } else {
            bullets.push({ x: player.x, y: player.y - 20 });
            playSfx(800, 'triangle', 0.05);
        }
    }
}, false);

canvas.addEventListener('touchmove', (e) => {
    if (joystick.active) {
        joystick.currX = e.touches[0].clientX;
        joystick.currY = e.touches[0].clientY;
    }
}, false);

canvas.addEventListener('touchend', () => { joystick.active = false; }, false);

function update() {
    // 星の移動
    stars.forEach(s => { s.y += s.s; if(s.y > canvas.height) s.y = -10; });

    // 自機移動
    if (joystick.active) {
        const dx = joystick.currX - joystick.startX;
        const dy = joystick.currY - joystick.startY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > 5) {
            player.x = Math.max(20, Math.min(canvas.width-20, player.x + (dx/dist)*player.speed));
            player.y = Math.max(20, Math.min(canvas.height-20, player.y + (dy/dist)*player.speed));
        }
    }

    bullets.forEach((b, bi) => { b.y -= 12; if (b.y < 0) bullets.splice(bi, 1); });

    // 敵の出現頻度を下げた (0.02 -> 0.01)
    if (Math.random() < 0.012) spawnEnemy();

    enemies.forEach((en, ei) => {
        en.y += en.speed;
        if (en.y > canvas.height) enemies.splice(ei, 1);

        // 自機との当たり判定（強制反映！）
        const distToPlayer = Math.sqrt((player.x - en.x)**2 + (player.y - en.y)**2);
        if (distToPlayer < 35) {
            playSfx(150, 'sawtooth', 0.2, 0.1);
            applyMath(en);
            enemies.splice(ei, 1);
        }

        // 弾との当たり判定
        bullets.forEach((b, bi) => {
            const dist = Math.sqrt((b.x - en.x)**2 + (b.y - en.y)**2);
            if (dist < 30) {
                playSfx(300, 'sine', 0.1);
                applyMath(en);
                enemies.splice(ei, 1);
                bullets.splice(bi, 1);
            }
        });
    });

    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 星空
    ctx.fillStyle = '#fff';
    stars.forEach(s => ctx.fillRect(s.x, s.y, s.s, s.s));

    // 方程式
    ctx.fillStyle = '#00ffcc';
    ctx.textAlign = 'center';
    ctx.font = 'bold 32px sans-serif';
    let lText = (fmt(coeff) === 1 ? "" : (fmt(coeff) === -1 ? "-" : fmt(coeff))) + "x";
    if (Math.abs(leftConst) > 0.01) {
        if (leftConst > 0) lText += " + " + fmt(leftConst);
        else lText += " - " + fmt(Math.abs(leftConst));
    }
    ctx.fillText(`${lText} = ${fmt(rightSide)}`, canvas.width / 2, 80);

    ctx.textAlign = 'left';
    ctx.font = '18px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText(`SCORE: ${score}`, 20, 40);

    // 敵
    enemies.forEach(en => {
        ctx.shadowBlur = 10; ctx.shadowColor = en.color;
        ctx.fillStyle = en.color;
        ctx.beginPath(); ctx.arc(en.x, en.y, 25, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = 'bold 18px sans-serif';
        ctx.fillText(en.label, en.x, en.y + 7);
    });

    // 自機
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(player.x, player.y - 20);
    ctx.lineTo(player.x - 15, player.y + 15);
    ctx.lineTo(player.x + 15, player.y + 15);
    ctx.fill();
}

generateEquation();
update();
</script>
</body>
</html>
